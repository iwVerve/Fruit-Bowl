<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprJigsawFox</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>21000</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>image_speed = 1/5;

var scale = 4;
image_xscale = scale;
image_yscale = scale;

x = (room_width - sprite_width) / 2;
y = (room_height - sprite_height) / 2;

tiles_h = 3;
tiles_v = 5;
tile_count = tiles_h * tiles_v;

margin = 32;
sprite_margin = margin / scale;
margin_right = sprite_width - margin;
margin_sprite_right = margin_right / image_xscale;
margin_bottom = sprite_height - margin;
margin_sprite_bottom = margin_bottom / image_yscale;

tile_width = (sprite_width - 2 * margin) / tiles_h;
tile_height = (sprite_height - 2 * margin) / tiles_v;
tile_sprite_width = tile_width / image_xscale;
tile_sprite_height = tile_height / image_yscale;

true_sprite_width = sprite_get_width(sprite_index);
true_sprite_height = sprite_get_height(sprite_index);

// Setup indexes
var indexes;
for(var i = 0; i &lt; tile_count; i += 1) {
    indexes[i] = i;
}

// Shuffle indexes
for(var i = tile_count - 1; i &gt; 0; i -= 1) {
    var j = irandom_range(0, i);
    if i != j {
        var temp = indexes[i];
        indexes[i] = indexes[j];
        indexes[j] = temp;
    }
}

// Initialize tiles from indexes
for(var j = 0; j &lt; tiles_v; j += 1) {
    for(var i = 0; i &lt; tiles_h; i += 1) {
        var index = tiles_h * j + i;
        var shuffled_index = indexes[index];
        var h = shuffled_index % tiles_h;
        var v = floor(shuffled_index / tiles_h);
        tile_x[index] = margin + h * tile_width;
        tile_y[index] = margin + v * tile_height;
        tile_target_x[index] = tile_x[index];
        tile_target_y[index] = tile_y[index];
        tile_left[index] = sprite_margin + i * tile_sprite_width;
        tile_top[index] = sprite_margin + j * tile_sprite_height;
    }
}

// State
selection = noone;
last_tile[0] = tile_count - 1;
last_tile[1] = tile_count - 2;
clear = false;
clear_check_time_duration = 10;
clear_check_time = clear_check_time_duration;
tile_alpha = 1;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if instance_exists(objPlayer) {
    if !clear &amp;&amp; input_check_pressed(KEY.SHOOT) {
    
        // Find selected tile
        var target = noone;
        for(var i = 0; i &lt; tile_count; i += 1) {
            if !in_range(objPlayer.x - x, tile_x[i], tile_x[i] + tile_width) {
                continue;
            }
            if !in_range(objPlayer.y - y, tile_y[i], tile_y[i] + tile_height) {
                continue;
            }
            target = i;
            break;
        }
        
        if target != noone {
            if selection == noone {
                selection = target;
            }
            else {
                // Swap
                var i = selection;
                var j = target;
                
                if i != j {
                    var temp_x = tile_target_x[i];
                    var temp_y = tile_target_y[i];
                    tile_target_x[i] = tile_target_x[j];
                    tile_target_y[i] = tile_target_y[j];
                    tile_target_x[j] = temp_x;
                    tile_target_y[j] = temp_y;
                    
                    last_tile[0] = i;
                    last_tile[1] = j;
                    
                    audio_play_sound(sndJigsawClick, 0, false);
                }
                selection = noone;
            }
        }
        else {
            // Missed !
            selection = noone;
        }
        
    }
}

for(var i = 0; i &lt; tile_count; i += 1) {
    var lerp_amount = 0.4;
    tile_x[i] = lerp(tile_x[i], tile_target_x[i], lerp_amount);
    tile_y[i] = lerp(tile_y[i], tile_target_y[i], lerp_amount);
}

if !clear {
    clear_check_time -= 1;
    if clear_check_time &lt;= 0 {
        clear = true;
        for(var i = 0; i &lt; tile_count; i += 1) {
            if point_distance(tile_x[i], tile_y[i], image_xscale * tile_left[i], image_yscale * tile_top[i]) &gt; 1 {
                clear = false;
                break;
            }
        }
        clear_check_time = clear_check_time_duration;
        
        if clear {
            selected = noone;
            
            instance_create(128 - 16, 304 - 16, objKnife);
        }
    }
}
else {
    tile_alpha -= 0.04;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>var mr = margin_right;
var mb = margin_bottom;
var msr = margin_sprite_right;
var msb = margin_sprite_bottom;

var tsw = true_sprite_width;
var tsh = true_sprite_height;

draw_sprite_part_ext(sprite_index, image_index, 0,   0, tsw, sprite_margin, x, y,      image_xscale, image_yscale, image_blend, image_alpha);
draw_sprite_part_ext(sprite_index, image_index, 0, msb, tsw, sprite_margin, x, y + mb, image_xscale, image_yscale, image_blend, image_alpha);
draw_sprite_part_ext(sprite_index, image_index, 0,   sprite_margin, sprite_margin, tsh - 2 * sprite_margin, x,      y + margin, image_xscale, image_yscale, image_blend, image_alpha);
draw_sprite_part_ext(sprite_index, image_index, msr, sprite_margin, sprite_margin, tsh - 2 * sprite_margin, x + mr, y + margin, image_xscale, image_yscale, image_blend, image_alpha);

for(var i = 0; i &lt; tile_count; i += 1) {
    if i == last_tile[0] || i == last_tile[1] {
        continue;
    }
    jigsaw_draw_tile(i);
}

for(var i = 0; i &lt; 2; i += 1) {
    jigsaw_draw_tile(last_tile[i]);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
